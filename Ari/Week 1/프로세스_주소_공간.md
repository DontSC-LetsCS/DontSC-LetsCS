# 프로세스의 주소 공간

![image](https://user-images.githubusercontent.com/75905803/203543969-c8f8bce1-7370-4a45-b23b-62f61a1c2859.png)

## 스택(Stack) 

* 먼저 들어간건 나중에 나온다. (LIFO 후위선출 구조)
* 할당과 해제를 반복하기 때문에 데이터 용량이 불확실하다.
* 메모리의 높은 주소부터 낮은 주소 순으로 할당 된다.
* 함수에 포함된 지역변수들만  접근할 수 있다.
* 컴파일 시에 할당될 영역의 크기가 결정된다. 정해진 크기를 넘어 할당할 수 없다.
* 함수를 호출할때마다 정보가 쌓인다. 함수의 호출이 완료되면 소멸한다.

</br>

## 힙(Heap)

* 프로그래머가 할당하고 해제해주는 영역. malloc, calloc 등 해제 기능이 필요하다.
* 런타임 시에 Heap영역의 크기가 결정되기 때문에 데이터 크기가 확실치 않을 때 사용된다.
* 낮은 주소에서 높은 주소 순으로 할당 된다.
* 스택보다 할당할 수 있는 메모리 공간이 많다는 것이 장점이지만 포인터로 메모리 영역을 접근해야 하기 때문에 다른 자료구조에 비해서 데이터를 읽고 쓰는게 느리다.
* 동적으로 할당되는 변수들이 할당되고 해제된다.
* 메모리 해제를 해주지 않으면 memory leak 발생한다. (동일 메모리 블록 중복 할당 방지 필요)

</br>

* 스택(Stack)과 힙(Heap)의 관계
  * 스택과 힙은 같은 공간을 사용한다.
  * 그래서 Stack 영역이 클 수록 Heap 영역이 작아지고, 반대로 Heap 영역이 클수록 Stack 영역이 작아진다. (반비례)
  * 같은 공간을 사용하기 때문에 서로 자신의 영역이 상대의 영역을 침범하는 사태가 발생할 수 있다.
  * Stack overflow: 스택이 힙의 영역 침범
  * Heap overflow: 힙이 스택의 영역 침법
  * Stack 영역에서 말하는 할당은 이미 생성된 공간에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction이기 때문에 할당 속도가 빠르다.
  * Heap 영역에서 말하는 할당은 요청되는 양과 현재 메모리 상황 등 다양한 요소를 고려해야 하기 때문에 더 많은 CPU Instruction이 필요하며 Stack보다 할당속도가 느리다.


</br>


## 데이터 (Data)

전역변수, Static변수 등이 저장되는 영역.</br>
할당된 데이터들은 프로그램이 실행되고 끝날때까지 메모리에 남아있다.</br>
BSS 영역과 Data 영역으로 구분지어 말할 수 있다.</br>

* `BSS`
  * 초기화되지 않은 변수가 저장된다.
  * 초기화된 데이터는 ROM의 Data 영역에 저장되는데, 아직 초기화되지 않은 데이터들 까지 ROM에 저장되면 큰사이즈의 ROM이 필요하기 때문에 BSS/DATA 영역을 나누어 저장한다.
* `Data`
  * 초기화 된 변수가 저장된다. 
  * ROM에 위치하고 있지만 전역변수와 Static변수를 ROM에 저장하면 런타임시 변경된 값이 적용되지 않고 초기값만 가지게 되므로, RAM에 Data 영역을 복사하여 런타임시 변경되는 값을 저장할 수 있도록 한다.
  * 따라서 프로그램 실행중 접근/수정/변경이 가능하다.

</br>

## Text(Code)

* 실행할 코드 (기계어 형태)
* 사용자가 작성한 코드나 Read-Only변수가 저장되는 영역으로 컴파일 이후 기계어 형태로 저장된다.
* 프로그램 실행되고 끝날 떄까지 메모리에 남아있다.
* Read-Only이기 때문에 수정이 불가하다.
