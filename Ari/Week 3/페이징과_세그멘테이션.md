# 페이징과 세그멘테이션

## Paging

![](https://i.imgur.com/5M1Xoqg.png)

* 프로세스는 페이지로 나누어지고, 물리메모리는 프레임으로 나누어진다.
* 페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장한다.
* CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경한다.
* 만약 프로세스가 프레임의 정수배보다 살짝 작다면 할당된 마지막 프레임은 전부 사용되지 않고 남아버리는 내부 단편화가 발생한다.
    * 페이지가 클 수록 내부 단편화가 커진다.
* 가상 메모리 사용

## Segmentation

![](https://i.imgur.com/3ztmE36.png)

* 사용자/프로그래머 관점의 메모리 관리 기법
* Segment
    * 페이지 같은 개념이지만, 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치한다.
* 프로세스를 Code, Data, Stack으로 나누는 것 역시 세그멘테이션
* 세그먼트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limint)를 엔트리로 가진다.
* 가상메모리 사용
* CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료한다.

## 페이징과 세그먼테이션의 차이

* 페이징은 고정 크기를 가진다. 반면에 세그먼테이션 가변 크기를 가진다.
* 페이징은 내부 단편화 발생이 가능하고, 세그먼테이션은 외부 단편화 발생 가능

## 페이징과 세그먼테이션을 사용하는 이유?

* Memory Fragmentation을 해결하기 위한 방법
* 다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 기법이 필요하다.

## 단순 페이지

* 각 프로세스는 프레임과 같은 길이를 가진 균등 페이지로 나뉜다.
* 외부 단편화가 생기지 않는다.
* 내부 단편화가 존재할 수 있다.

## 단순 세그멘테이션

* 각 프로세스는 여러 세그먼트로 나뉜다.
* 내부 단편화가 생기지 않는다.
* 메모리 효율을 개선한다.
* 동적 분할을 통한 오버헤드가 감소한다.
* 외부 단편화가 존재할 수 있다.

## 가상 메모리 페이징

* 단순 페이징과 비교해 프로세스 페이지 전부를 로드할 필요가 없다.
* 필요한 페이지가 있다면 나중에 자동으로 불러들인다.
* 외부 단편화가 생기지 않는다.
* 복잡한 메모리 관리로 오버헤드가 발생할 수 있다.

## 가상 메모리 세그멘테이션

* 필요하지 않은 세그먼트들은 로드되지 않는다.
* 필요한 세그먼트가 있을 때 나중에 자동으로 불러 들인다.
* 내부 단편화가 생기지 않는다.
* 복잡한 메모리 관리로 오버헤드가 발생할 수 있다.
