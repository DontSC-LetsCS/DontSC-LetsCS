# 가상 메모리 (Virtual Memory)

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상 메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

## 개발 배경

과거에는 실행되는 코드의 전부를 물리 메모리에 올려야 했고, 실행하고자 하는 코드가 메모리보다 클 경우에는 아예 실행할 수 없었다. 또한 여러 프로그램이 동시에 메모리에 올라가는 것은 용량 문제나 페이지 스위칭 등의 성능 이슈가 발생하였다. 가끔만 사용되는 코드 또한 물리 메모리에 올라가 메모리 공간을 차지하는 것을 보고 프로그램 전체를 메모리에 올리지 않아도 실행시킬 수 있겠다는 아이디어가 탄생했다.

프로그램의 일부만을 메모리에 올려도 실행이 가능하게 되면 다음과 같은 이점들을 챙길 수 있게 된다.

* 물리 메모리 크기에 제약받지 않게 된다.
* 더 많은 프로그램들을 동시에 실행할 수 있게 된다.
    * 이에 따라 응답 시간은 유지되고, CPU 이용율과 처리율은 높아진다
* swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.


## 가상 메모리가 하는 일

가상 메모리는 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.

* 가상 주소 공간
    * 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간
    * 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로써 현재 직접적으로 필요치 않은 메모리 공간을 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.
    * ex) 한 프로그램이 실행되기 위해 100KB 논리 메모리가 필요하고, 실행까지 필요한 메모리 공간(Heap, Stack, Code, Data)의 합이 40KB일 경우 실제 물리 메모리에는 40KB만 올라가 있고, 나머지 60KB만큼은 필요시에 물리 메모리에 요구한다.
* 프로세스 간의 페이지 공유
    * 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다
    * 각 프로세스들은 공유 라이브러리를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가 있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.
    * 프로세스 간의 메모리 공유를 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다.
    * 이 또한 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
    * fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.


## Demand Paging (요구 페이징)

![](https://i.imgur.com/2ZlB9hl.png)

프로그램 실행 시작 시 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 의미한다. </br>
이는 가상 메모리 시스템에서 많이 사용된다. 가상 메모리는 대개 페이지로 관리되는데, 요구 페이징을 사용하는 가상 메모리에서는 실행 과정에서 필요해질 때 페이지들이 적재된다. 한번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다. </br>
프로세스 내의 개별 페이지들은 페이저(pager)에 의해 관리 된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어와 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄여준다.

## 유효-무효 비트 (Valid-Invalid Bit)

![](https://i.imgur.com/MaXFiqt.png)

* 페이지가 메모리에 올라와 있는지 구별을 위해 페이지 테이블에 유효-무효 비트 표시
    * 유효비트(v, valid)로 세트되면 페이지가 메모리에 있음을 표시
    * 무효비트(i, invalid)로 세트되면 페이지가 메모리에 없음을 표시
    * 초기에는 i로 지정
* 주소 변환 중 무표비트 i로 세트되어 있으면 페이지 부재(page fault)발생
* 일부 페이지들이 메인 메모리에 없는 경우 페이지 테이블

## 페이지 부재 (Page Fault)

![](https://i.imgur.com/I1z1Ezk.png)

프로세스가 메모리에 올라와 있지 않은 페이지를 접근하는 경우 페이지 부재(page-fault) 트랩(trap)이 발생한다.

* 페이지 부재 처리 과정
    * 운영체제는 내부 테이블(PCB와 함께 유지)을 검사하여 메모리 참조가 유효인지 무효인지를 조사한다.
        * 무효한 참조 -> 프로세스 중단
        * 메모리에 없는 유효한 참조
    * 빈 공간 즉, 자유 프레임(free frame)을 검색한다.
    * 새롭게 할당된 프레임으로 해당 페이지를 읽어들이도록 요청한다.
    * 페이지 테이블을 갱신한다 (유효비트 세트)
    * 페이지 부재 트랩에 의해 중단되었던 명령어를 다시 수행한다.

## 요구 페이징의 성능(Performance of Demand Paging)

유효 접근 시간(effective access time) = (1-p) ma + p (페이지 부재 처리 시간)

* p
    * 페이지의 부재 확률, 0≤p≤1.0
* ma
    * 메모리 접근 시간(memory access time)
* 페이지 부재 처리 시간
    * 인터럽트 처리, 페이지 읽기, 프로세스 재시작

## 쓰기 시 복사 (copy-on-write)

![](https://i.imgur.com/gbe2lHt.png)

가상 메모리는 프로세스 생성(fork())시 페이지를 공유하여 생성 시간을 줄인다. (쓰기 시 복사 적용)

* 자식 프로세스가 시작할 때 부모의 페이지를 당분간 함께 공유하여 사용한다.
* 둘 중 한 프로세스가 공유 중인 페이지에 쓸 때 페이지의 복사본이 생성된다.
* 수정되는 페이지만 복사본을 만들어 효율적인 프로세스를 생성한다.

## 페이지 교체 (Page Replacement)

모든 메모리가 사용 중이어서 빈 프레임이 없는 경우에는 페이지 교체를 시도한다.

* 페이지 교체 알고리즘(Page replacement algorithm)
    * 새로운 페이지는 메모리로 가져온다.
    * 교체되는 페이지(victim)는 디스크에 저장한다.
        * 수정되는 페이지만을 디스크에 저장하여 페이지 전송 오버헤드를 줄인다.
        * 변경 비트(modify bit, dirty bit) 사용
    * 성능
        * 페이지 부재가 최소가 되도록 기대
        * 일부 페이지는 자주 교체되어 메모리에 여러번 가져오는 경우도 발생

### 기본적인 페이지 교체

물리 메모리가 모두 사용 중일 경우의 메모리 교체 흐름.

* 디스크에서 필요한 페이지의 위치를 알아낸다
* 빈 페이지 프레임을 찾는다
    * 빈 프레임이 있다면 그것을 사용한다.
    * 없다면, 희생될(victim) 프레임을 선정하기 위해 페이지 교체 알고리즘을 가동한다.
    * 희생될 페이지를 디스크에 기록하고 관련 테이블을 수정한다
* 새롭게 비워진 프레임에 새 페이지를 읽어오고 테이블을 수정한다.
* 사용자 프로세스를 재시작한ㄷ.

### 페이지 교체 알고리즘(Page Replacement Algorithm)

![](https://i.imgur.com/SBaBe45.png)

페이지 부재율(page-fault rate)이 가장 낮은 것을 선정한다.

* 성능
    * 특정 메모리 참조 나열에 대해 알고리즘을 적용하여 페이지 부재 발생 횟수를 계산하여 평가
    * 메모리 주소의 나열을 참조열(reference string)이라고 한다.

### FIFO 페이지 교체 (FIFO Page Replacement)

![](https://i.imgur.com/C9zSlKl.png)

가장 간단한 페이지 교체 알고리즘이다. 먼저 물리 메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나가게 된다.

* 장점
    * 이해하기 쉽고 구현도 쉽다.
* 단점
    * 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수도 있다. (초기 변수 등)
    * 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수도 있다.
    * Belady의 모순
        * 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 발생한다.


### 최적 페이지 교체 (Optimal Page Replacement)

![](https://i.imgur.com/08mpR22.png)

앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다. 주로 비교 연구 목적을 위해 사용한다. (실제 구현보다는 다른 알고리즘과 비교하여 이와 비슷한 결과일 수록 좋은 알고리즘임을 평가함)

* 장점
    * 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
* 단점
    * 구현의 어려움이 있음. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

이 알고리즘은 실제로 구현할 수 없다. 보통 다른 교체 알고리즘의 성능을 평가하기 위한 지표로 사용된다. Optimal은 앞으로 해당 페이지가 얼마나 사용되는지의 여부를 통해 가장 사용되지 않을 페이지를 디스크로 내리는 알고리즘이다. 미래는 알 수 없기 때문에 구현 불가능하다.

### LRU 페이지 교체 (Least Recently Used Page Replacement)

![](https://i.imgur.com/PeWSKkx.png)

최적 알고리즘의 근사 알고리즘으로 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. 즉 마지막 접근 시간이 가장 오래된 페이지를 디스크로 내리는 알고리즘으로 Optimal에 어느정도 근사한 알고리즘이다.

* 구현
    * 계수기(counter)
        * 각 페이지 항목마다 계수기 추가
        * 페이지 참조마다 계수기 증가
        * 페이지 교체 시 가장 작은 값의 계수기의 페이지를 교체한다.
            * LRU 페이지를 찾기 위해 페이지 테이블 검색
            * 메모리 참조마다 계수기 갱신을 위해 메모리 스기
    * 스택(Stack)
        * 페이지 번호의 스택을 유지
            * 스택은 보통 이중 연결 리스트로 구현
        * 페이지가 참조될 때마다 페이지 번호는 스택 중간에서 제거되어 스택 top에 놓인다.
            * 페이지 테이블 검색 필요 없음
            * 포인터 값 변경 오버헤드
* 특징
    * 대체적으로 FIFO 알고리즘 보다 우수하고, 최적 알고리즘 보다는 그렇지 못한다.

### LFU 페이지 교체

페이지의 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘. 즉 가장 조금 접근한 페이지를 디스크로 내리는 알고리즘으로 특정 페이지를 집중적으로 접근하다가 앞으로 사용하지 않게 되어도 접근 횟수가 높기 때문에 물리 메모리에서 내려오지 않게 된다. Optimal과 거리가 멀기 때문에 잘 사용되지 않는다.

</br>

* 최저 참조 횟수인 페이지가 여러 개 있는 경우
  * LFU 알고리즘 자체에서는 여러 페이지 중 임의로 선정한다.
  * 성능 향상을 위해 가장 오래전에 참조된 페이지를 지우게 구현할 수 있다.
* 장점
    * LRU 처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 페이지의 인기도를 좀더 정확히 반영할 수 있다.
* 단점 
    * 참조 시점의 최근성을 반영하지 못한다.
    * LRU보다 구현이 복잡하다.
