# 페이지 교체 알고리즘(Page Replacement Algorithm)

![](https://i.imgur.com/SBaBe45.png)

필요한 페이지가 메모리에 없을 때 page-falut가 발생하고 Backing Store에서 해당 페이지를 찾아 빈 프레임에 로딩해야 하는데, 이때 빈 프레임이 없을 경우 희생당할 프레임(victim frame)을 고르는 알고리즘이 페이지 교체 알고리즘이다.
즉 페이지 부재율(page-fault rate)이 가장 낮은 것을 선정한다.

* 성능
    * 특정 메모리 참조 나열에 대해 알고리즘을 적용하여 페이지 부재 발생 횟수를 계산하여 평가
    * 메모리 주소의 나열을 참조열(reference string)이라고 한다.

</br>

## FIFO 페이지 교체 (FIFO Page Replacement)

![](https://i.imgur.com/C9zSlKl.png)

가장 간단한 페이지 교체 알고리즘이다. 먼저 물리 메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나가게 된다.

* 장점
    * 이해하기 쉽고 구현도 쉽다.
* 단점
    * 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수도 있다. (초기 변수 등)
    * 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수도 있다.
    * Belady의 모순
        * 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 발생한다.

</br>

## 최적 페이지 교체 (Optimal Page Replacement)

![](https://i.imgur.com/08mpR22.png)

앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다. 주로 비교 연구 목적을 위해 사용한다. (실제 구현보다는 다른 알고리즘과 비교하여 이와 비슷한 결과일 수록 좋은 알고리즘임을 평가함)

* 장점
    * 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
* 단점
    * 구현의 어려움이 있음. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

이 알고리즘은 실제로 구현할 수 없다. 보통 다른 교체 알고리즘의 성능을 평가하기 위한 지표로 사용된다. Optimal은 앞으로 해당 페이지가 얼마나 사용되는지의 여부를 통해 가장 사용되지 않을 페이지를 디스크로 내리는 알고리즘이다. 미래는 알 수 없기 때문에 구현 불가능하다.

</br>

## LRU 페이지 교체 (Least Recently Used Page Replacement)

![](https://i.imgur.com/PeWSKkx.png)

최적 알고리즘의 근사 알고리즘으로 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. 즉 마지막 접근 시간이 가장 오래된 페이지를 디스크로 내리는 알고리즘으로 Optimal에 어느정도 근사한 알고리즘이다.

* 구현
    * 계수기(counter)
        * 각 페이지 항목마다 계수기 추가
        * 페이지 참조마다 계수기 증가
        * 페이지 교체 시 가장 작은 값의 계수기의 페이지를 교체한다.
            * LRU 페이지를 찾기 위해 페이지 테이블 검색
            * 메모리 참조마다 계수기 갱신을 위해 메모리 스기
    * 스택(Stack)
        * 페이지 번호의 스택을 유지
            * 스택은 보통 이중 연결 리스트로 구현
        * 페이지가 참조될 때마다 페이지 번호는 스택 중간에서 제거되어 스택 top에 놓인다.
            * 페이지 테이블 검색 필요 없음
            * 포인터 값 변경 오버헤드
* 특징
    * 대체적으로 FIFO 알고리즘 보다 우수하고, 최적 알고리즘 보다는 그렇지 못한다.

</br>

## LFU 페이지 교체

페이지의 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘. 즉 가장 조금 접근한 페이지를 디스크로 내리는 알고리즘으로 특정 페이지를 집중적으로 접근하다가 앞으로 사용하지 않게 되어도 접근 횟수가 높기 때문에 물리 메모리에서 내려오지 않게 된다. Optimal과 거리가 멀기 때문에 잘 사용되지 않는다.

</br>

* 최저 참조 횟수인 페이지가 여러 개 있는 경우
  * LFU 알고리즘 자체에서는 여러 페이지 중 임의로 선정한다.
  * 성능 향상을 위해 가장 오래전에 참조된 페이지를 지우게 구현할 수 있다.
* 장점
    * LRU 처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 페이지의 인기도를 좀더 정확히 반영할 수 있다.
* 단점 
    * 참조 시점의 최근성을 반영하지 못한다.
    * LRU보다 구현이 복잡하다.
